Index: lib/Socket.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lib/Socket.py	(revision )
+++ lib/Socket.py	(revision )
@@ -0,0 +1,145 @@
+#! /usr/bin/env python3
+# -*- coding:  UTF-8 -*-
+
+import socket
+MAX_LENGTH_OF_MSG= 1024-1-2 
+from common import DumpStack
+
+def startTCPServer(host='localhost', port=50000):
+    #Sock = socket.socket()
+    #Binding socket to a address. bind() takes tuple of host and port.
+    
+    Sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) 
+    Sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) 
+    Sock.bind((host, int(port)))
+    #Listening at the address
+    Sock.listen(0) #5 denotes the number of clients can queue    
+    return Sock
+
+def Rx(conn):
+    try:
+        EndOfMsg=False
+        rcvdata=None
+        msg=[]
+        #conn.settimeout(1.5)        
+        while not EndOfMsg :
+            rcvdata = conn.recv(1024)#.decode() # 1024 stands for bytes of data to be received
+            if len(rcvdata)>0:
+                EndOfMsg=int(ord(rcvdata[0]))
+                MsgLength = int(ord(rcvdata[1]))*255+ int(ord(rcvdata[2]))
+                data = rcvdata[3:]
+                data = list(data)
+                msg=msg+data 
+        
+        msg = ''.join(e for e in msg)  
+        tmpmsg = msg.split(',')
+        #=======================================================================
+        # #print('CSocket::Rx Msg:')
+        # for seg in tmpmsg:
+        #     try:
+        #         print('\t%s'%(base64.b64decode(seg).decode()))
+        #     except:
+        #         print('\t%s'%seg)
+        # print('CSocket::Rx Msg end')
+        #=======================================================================
+
+        return msg
+    except Exception as e:
+        response= ('Rx() Failed:\n%s'%(DumpStack(e).replace('\n','\t\n'))) 
+        #print(response)
+        return response
+def EncodeMsg(data='', EndOfMsg=1):
+    data= list(data)
+    length= len(data)                
+    data.insert(0,chr(int(length%255)))
+    data.insert(0,chr(int(length/255)))
+    data.insert(0,chr(EndOfMsg))
+    data =''.join(e for e in data)
+    #data= str(data).encode(encoding = 'utf_8' , errors='strict')#encoding='utf_8', errors='strict')
+    return data
+        
+def Tx(conn,msg):  
+    global MAX_LENGTH_OF_MSG        
+    try:
+        msg=list(msg)
+        block= int(len(msg)/MAX_LENGTH_OF_MSG)
+        index = 0
+       # 'h', 'o', 's', 't', '\\', 'r', '\\', 'n', '6', '4', ' ', 'b', 'y', 't', 'e', 's', ' ', 'f', 'r', 'o', 'm', ' ', '1', '2', '7', '.', '0', '.', '0', '.', '1', ':', ' ', 'i', 'c', 'm', 'p', '_', 'r', 'e', 'q', '=', '2', ' ', 't', 't', 'l', '=', '6', '4', ' ', 't', 'i', 'm', 'e', '=', '0', '.', '6', '4', '6', ' ', 'm', 's', '\\', 'r', '\\', 'n', '6', '4', ' ', 'b', 'y', 't', 'e', 's', ' ', 'f', 'r', 'o', 'm', ' ', '1', '2', '7', '.', '0', '.', '0', '.', '1', ':', ' ', 'i', 'c', 'm', 'p', '_', 'r', 'e', 'q', '=', '3', ' ', 't', 't', 'l', '=', '6', '4', ' ', 't', 'i', 'm', 'e', '=', '0', '.', '2', '5', '6', ' ', 'm', 's', '\\', 'r', '\\', 'n', '6', '4', ' ', 'b', 'y', 't', 'e', 's', ' ', 'f', 'r', 'o', 'm', ' ', '1', '2', '7', '.', '0', '.', '0', '.', '1', ':', ' ', 'i', 'c', 'm', 'p', '_', 'r', 'e', 'q', '=', '4', ' ', 't', 't', 'l', '=', '6', '4', ' ', 't', 'i', 'm', 'e', '=', '0', '.', '2', '6', '0', ' ', 'm', 's', '\\', 'r', '\\', 'n', '6', '4', ' ', 'b', 'y', 't', 'e', 's', ' ', 'f', 'r', 'o', 'm', ' ', '1', '2', '7', '.', '0', '.', '0', '.', '1', ':', ' ', 'i', 'c', 'm', 'p', '_', 'r', 'e', 'q', '=', '5', ' ', 't', 't', 'l', '=', '6', '4', ' ', 't', 'i', 'm', 'e', '=', '0', '.', '2', '5', '3', ' ', 'm', 's', '\\', 'r', '\\', 'n', '\\', 'r', '\\', 'n', '-', '-', '-', ' ', 'l', 'o', 'c', 'a', 'l', 'h', 'o', 's', 't', ' ', 'p', 'i', 'n', 'g', ' ', 's', 't', 'a', 't', 'i', 's', 't', 'i', 'c', 's', ' ', '-', '-', '-', '\\', 'r', '\\', 'n', '5', ' ', 'p', 'a', 'c', 'k', 'e', 't', 's', ' ', 't', 'r', 'a', 'n', 's', 'm', 'i', 't', 't', 'e', 'd', ',', ' ', '5', ' ', 'r', 'e', 'c', 'e', 'i', 'v', 'e', 'd', ',', ' ', '0', '%', ' ', 'p', 'a', 'c', 'k', 'e', 't', ' ', 'l', 'o', 's', 's', ',', ' ', 't', 'i', 'm', 'e', ' ', '4', '4', '1', '8', 'm', 's', '\\', 'r', '\\', 'n', 'r', 't', 't', ' ', 'm', 'i', 'n', '/', 'a', 'v', 'g', '/', 'm', 'a', 'x', '/', 'm', 'd', 'e', 'v', ' ', '=', ' ', '0', '.', '2', '5', '3', '/', '0', '.', '3', '4', '4', '/', '0', '.', '6', '4', '6', '/', '0', '.', '1', '5', '3', ' ', 'm', 's', '\\', 'r', '\\', 'n', 'S', 'L', 'V', '1', '>', '"']
+        while index <=block:                
+            index =index+1
+            EndOfMsg=0
+            if index>block:
+                EndOfMsg=1
+            data = msg[(index-1)*MAX_LENGTH_OF_MSG:(index)*MAX_LENGTH_OF_MSG]
+            data =EncodeMsg(data, EndOfMsg)
+            s=''
+            for c in data[4:]:
+                try:
+                    c = chr(c)
+                except:
+                    c = c
+                s+=c
+            s.replace('\n','\n\t')
+            #print('CSocket::Tx Msg:')
+            #print('\t',s)
+            #print('CSocket::Tx Msg end')
+            conn.send(data)
+
+    except Exception as e:
+        import traceback
+        errormessage = traceback.format_exc()
+        print(errormessage)
+        print('Tx():%s: msg(%s), block:%d'%(str(e),  ''.join(msg), block))
+
+def SendRequest2Server(host,port, msg): 
+    try:
+        import socket
+        #print(host,port,msg)
+        sock=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
+        sock.connect((host,int(port)))
+        global MAX_LENGHT_OF_MSG
+        block= int(len(msg)/MAX_LENGTH_OF_MSG)
+        index = 0
+        while index <=block:
+            #print('index: %d, total block:%d'%(index, block))
+            index =index+1
+            EndOfMsg=False
+            if index>block:
+                EndOfMsg=True
+            data = msg[(index-1)*MAX_LENGTH_OF_MSG:(index)*MAX_LENGTH_OF_MSG]
+            data =EncodeMsg(data, EndOfMsg)
+            sock.send(data)
+    
+        EndOfMsg=False
+        rcvdata=None
+        msg=[]
+        msg = Rx(sock)
+        sock.close()
+        return msg
+    
+    except Exception as e:
+        print(e)
+        return str(e)
+
+def cmd2(host, port, cmd):
+    import json
+    jcmd =json.dumps(cmd)
+    from CSocket import SendRequest2Server  
+    resp = SendRequest2Server(host, port, jcmd)
+    return resp
+
+if __name__=='__main__':
+    msg = ['"', 'h', 'o', 's', 't', '\\', 'r', '\\', 'n', '6', '4', ' ', 'b', 'y', 't', 'e', 's', ' ', 'f', 'r', 'o', 'm', ' ', '1', '2', '7', '.', '0', '.', '0', '.', '1', ':', ' ', 'i', 'c', 'm', 'p', '_', 'r', 'e', 'q', '=', '2', ' ', 't', 't', 'l', '=', '6', '4', ' ', 't', 'i', 'm', 'e', '=', '0', '.', '6', '4', '6', ' ', 'm', 's', '\\', 'r', '\\', 'n', '6', '4', ' ', 'b', 'y', 't', 'e', 's', ' ', 'f', 'r', 'o', 'm', ' ', '1', '2', '7', '.', '0', '.', '0', '.', '1', ':', ' ', 'i', 'c', 'm', 'p', '_', 'r', 'e', 'q', '=', '3', ' ', 't', 't', 'l', '=', '6', '4', ' ', 't', 'i', 'm', 'e', '=', '0', '.', '2', '5', '6', ' ', 'm', 's', '\\', 'r', '\\', 'n', '6', '4', ' ', 'b', 'y', 't', 'e', 's', ' ', 'f', 'r', 'o', 'm', ' ', '1', '2', '7', '.', '0', '.', '0', '.', '1', ':', ' ', 'i', 'c', 'm', 'p', '_', 'r', 'e', 'q', '=', '4', ' ', 't', 't', 'l', '=', '6', '4', ' ', 't', 'i', 'm', 'e', '=', '0', '.', '2', '6', '0', ' ', 'm', 's', '\\', 'r', '\\', 'n', '6', '4', ' ', 'b', 'y', 't', 'e', 's', ' ', 'f', 'r', 'o', 'm', ' ', '1', '2', '7', '.', '0', '.', '0', '.', '1', ':', ' ', 'i', 'c', 'm', 'p', '_', 'r', 'e', 'q', '=', '5', ' ', 't', 't', 'l', '=', '6', '4', ' ', 't', 'i', 'm', 'e', '=', '0', '.', '2', '5', '3', ' ', 'm', 's', '\\', 'r', '\\', 'n', '\\', 'r', '\\', 'n', '-', '-', '-', ' ', 'l', 'o', 'c', 'a', 'l', 'h', 'o', 's', 't', ' ', 'p', 'i', 'n', 'g', ' ', 's', 't', 'a', 't', 'i', 's', 't', 'i', 'c', 's', ' ', '-', '-', '-', '\\', 'r', '\\', 'n', '5', ' ', 'p', 'a', 'c', 'k', 'e', 't', 's', ' ', 't', 'r', 'a', 'n', 's', 'm', 'i', 't', 't', 'e', 'd', ',', ' ', '5', ' ', 'r', 'e', 'c', 'e', 'i', 'v', 'e', 'd', ',', ' ', '0', '%', ' ', 'p', 'a', 'c', 'k', 'e', 't', ' ', 'l', 'o', 's', 's', ',', ' ', 't', 'i', 'm', 'e', ' ', '4', '4', '1', '8', 'm', 's', '\\', 'r', '\\', 'n', 'r', 't', 't', ' ', 'm', 'i', 'n', '/', 'a', 'v', 'g', '/', 'm', 'a', 'x', '/', 'm', 'd', 'e', 'v', ' ', '=', ' ', '0', '.', '2', '5', '3', '/', '0', '.', '3', '4', '4', '/', '0', '.', '6', '4', '6', '/', '0', '.', '1', '5', '3', ' ', 'm', 's', '\\', 'r', '\\', 'n', 'S', 'L', 'V', '1', '>', '"']
+
+    aaa = EncodeMsg(msg)
+    #resp =SendRequest2Server('localhost', 50010 ,'dump("abc")')
+    #print(resp)
+    #resp =SendRequest2Server('localhost', 50010 ,'''"tel,ActionCheck([tel','ls','~]',30])"''')
+   #bad print(SendRequest2Server('localhost', 50010 ,'''tel,ActionCheck([tel','ls','~]',30]),'''))
+
+    print(SendRequest2Server('localhost', 50010 ,'''__case__,"ActionCheck(['tel','ls',']',2])",.,2,,,'''))
+    #print(SendRequest2Server('localhost', 50010 ,'''tel,"ActionCheck(['tel','ls',']',2])",.,2,,,'''))
+    # good
+    print(SendRequest2Server('localhost', 50010 ,'''tel,ls,],10,,,,'''))
+     
+    print("Socket client end!!!!!!!!!!!!")        
\ No newline at end of file
Index: lib/Case.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lib/Case.py	(revision )
+++ lib/Case.py	(revision )
@@ -0,0 +1,648 @@
+#! /usr/bin/env python3
+# -*- coding:  UTF-8 -*-
+__author__ = 'Sean Yu'
+__mail__ = 'try.dash.now@gmail.com'
+
+import os,time,re
+import sys
+sys.path.append(os.getcwd())
+from common import DumpStack
+import threading
+reCtrl = re.compile("^\s*ctrl\s*:(.*)", re.I)
+reAlt = re.compile("^\s*alt\s*:(.*)", re.I)
+reCtrlAlt = re.compile("^\s*ctrlalt\s*:(.*)", re.I)
+reRetry = re.compile("^\s*try\s+([0-9]+)\s*:(.*)", re.I)
+reNoAction =re.compile("[\s]*NOACTION[\s]*:([\s\S]*)",re.IGNORECASE)
+reNoWait =re.compile("[\s]*NOWAIT[\s]*:([\s\S]*)",re.IGNORECASE)
+reNo = re.compile("^\s*NO\s*:(.*)", re.I)
+
+reSegementIndex =re.compile ('\s*(SETUP|RUN|TEARDOWN)\s*.\s*([+-]*\d+)',re.I)
+
+from common import csvstring2array,csvfile2array
+
+if os.name!='nt':
+    import queue
+else:
+    import Queue as queue
+class Case(object):
+    LogDir= './'
+    Name= 'DefaultTestCaseName'
+    SUTs={}
+    Session={}
+    Steps=[[],[],[]]
+    logger=None
+    
+    arg =[]
+    kwarg = {}  
+    argvs=[]
+    kwargvs =[]
+    thInteraction =None
+    bCaseEnd=False
+    MoniterInterval =1 #second
+    ServerPort=50000
+    ServerHost ='localhost'
+    #CasePort=50001
+    #CaseHost ='localhost'
+    SocketResponse=''
+    Sock=None
+    Mode= 'FULL'
+    breakpoint=[[],[],[]]
+    flagInteraction=False
+    cp=[0,1]
+    thWebclient =None
+    CaseFailed= True
+    DebugWhenFailed=False
+    qCommand=queue.Queue()
+    fRunning= False
+    RecordReplay=[]
+    IndexOfSutOutput ={'client':{'tel':[0,0]}}
+    SUTNAME =[]
+    InitialDone=False
+    fActionInProgress=False
+    lockOutput = None
+    lockRR =None
+    def SaveCase2File(self):
+        import csv
+        MAX_LENGTH_OF_CELL =256
+        csvfile = './html/case/manual/%s'%(self.Name+time.strftime("_%Y%m%d_%H%M%S", time.localtime()))
+        with open(csvfile, 'w') as f:
+            writer = csv.writer(f)
+            for row in self.RecordReplay:
+                maxlen= 0
+                for item in row:
+                    l = len(item)
+                    if l> maxlen:
+                        maxlen = l
+                if maxlen > MAX_LENGTH_OF_CELL:
+                    index = 0
+                    block =0
+                    maxcol = len(row)
+                    newrow =[]
+                    while index <maxlen:
+                        for i in range(maxcol):
+                            newrow.append(row[i][block:(block+1)*MAX_LENGTH_OF_CELL]) 
+                        writer.writerow(newrow)
+                        block+=1
+                        index=block*MAX_LENGTH_OF_CELL
+                        
+                else:
+                    writer.writerow(row)   
+            writer.writerow(['#!---'])
+    def GetCurrentSutOutputIndex(self,sut):
+        recordIndex = len(self.RecordReplay)-1
+        colIndex = 4   +  self.SUTNAME.index(sut )
+        offset = len(self.RecordReplay[recordIndex][colIndex])
+        return [recordIndex,offset]
+    def UpdateSutOutput2RecordReplay(self, sutname, data):
+        self.lockRR.acquire()
+        colIndex = 4   +  self.SUTNAME.index(sutname )
+        rowIndex = len(self.RecordReplay)-1
+        while len (self.RecordReplay[rowIndex])<colIndex+2:            
+            self.RecordReplay[rowIndex].append('')
+        self.RecordReplay[rowIndex][colIndex] = '''%s'''%(self.RecordReplay[rowIndex][colIndex]+ data)
+        self.lockRR.release()
+        
+    def AddCmd2RecordReplay(self,cmd):
+        newrecord = cmd[1:]
+        if cmd[0]=='__case__':
+            newrecord[0]='''#%s'''%newrecord[0]
+        else:
+            newrecord =cmd[:]
+        while len(newrecord)<4:
+            newrecord.append('')
+        for sut in self.SUTNAME:            
+            newrecord.append('')    
+        self.lockOutput.acquire()    
+        self.RecordReplay.append(newrecord)
+        self.lockOutput.release()
+    def AddClient(self, clientid):
+        #lock= threading.Lock()
+        self.lockOutput.acquire()
+        self.IndexOfSutOutput.update({clientid:{}})
+        for sut in self.Session.keys():
+            self.IndexOfSutOutput[clientid].update({sut:self.GetCurrentSutOutputIndex(sut)})
+            time.sleep(2)
+        self.lockOutput.release()
+        return 'Client %s Added'%clientid
+    def RequestSUTOutput(self,client, sut):
+
+            
+        response = ''
+        self.lockOutput.acquire()
+        try:
+            [recordIndex, offset] = self.IndexOfSutOutput[client][sut]
+            cRecordIndex = len(self.RecordReplay)-1
+
+            index = recordIndex
+            colIndex =4   +  self.SUTNAME.index(sut )
+            response = self.RecordReplay[index][colIndex][offset:]
+            index +=1
+            while cRecordIndex>=index:
+                response = response + self.RecordReplay[index][colIndex][:]
+                index +=1
+            self.IndexOfSutOutput[client][sut]=self.GetCurrentSutOutputIndex(sut)
+            time.sleep(0.2)
+        except Exception as e:
+            print('#####'*160)
+            
+            respone = DumpStack(e)
+            self.error(response)
+        self.lockOutput.release()
+        return response 
+
+    def QuerySUTOutput(self):
+        self.info('QuerySUTOutput() is called,')
+        while self.fActionInProgress:
+            time.sleep(1)
+        self.info('QuerySUTOutput(), Expect switchs to search in InteractionBuffer')
+        for ses in self.SUTs:
+            self.Session[ses].SetInteractionMode(True)
+        if os.name !='nt':
+            import pexpect
+
+        while (not self.bCaseEnd) and self.flagInteraction :
+            for sutname in self.SUTs.keys():
+                acquired =self.lockOutput.acquire()
+                try:       
+                    self.Session[sutname].match=None
+                    if self.InitialDone and (not self.Session[sutname].fSending):
+                        if not acquired:
+                            continue
+                        if os.name =='nt':
+                            try:
+                                self.Session[sutname].match =self.Session[sutname].read_until('.+',0.01)
+                            except Exception as e:
+                                self.Session[sutname].match =''
+
+                        else:
+                            import pexpect
+                            self.Session[sutname].expect(['.+',pexpect.TIMEOUT], 0,01)
+
+                        match = self.Session[sutname].match
+                        output=''
+                        try:
+                            if os.name =='nt':
+                                if match!='':# and match!=pexpect.TIMEOUT :
+                                    output = match #match.group().decode("utf-8")
+                            else:
+                                if match and match!=pexpect.TIMEOUT :
+                                    output = match.group().decode('utf-8') #match.group().decode("utf-8")
+                        except Exception as e:
+                            self.error(DumpStack(e))
+                        if len(output)>0:
+                            self.Session[sutname].AppendData2InteractionBuffer(output)
+                            self.UpdateSutOutput2RecordReplay(sutname, output)
+                            
+                            
+                    
+                except Exception as e:
+
+                    if str(e.__str__).startswith('End Of File (EOF).'):
+                        try:
+                            self.Session[sutname].SendLine('')
+                        except Exception as e: 
+                            self.error(DumpStack(e))
+                    else:            
+                        self.error(DumpStack(e))
+                self.lockOutput.release()
+                time.sleep(0.49)
+                
+        print('Query SUT Output ended')
+                #time.sleep(0.2)        
+    def info(self,msg):
+        self.logger.info(msg)
+        self.UpdateSutOutput2RecordReplay('__case__', msg)
+    def debug(self,msg):
+        self.logger.debug(msg)
+        self.UpdateSutOutput2RecordReplay('__case__', msg)
+    def error(self,msg):
+        self.logger.error(msg)
+        self.UpdateSutOutput2RecordReplay('__case__', msg)
+        
+    def __init__(self,name,suts,steps=None,mode=None,DebugWhenFailed=False,logdir=None,caseconfigfile=None):
+        if not steps :
+            steps = [[],[],[]]
+        if not mode:
+            mode ='FULL'
+        if not logdir:
+            logdir = os.getcwd()
+        if not caseconfigfile:
+            caseconfigfile = './case.cfg'
+
+        import threading
+        self.lockOutput =threading.Lock()
+        self.lockRR =threading.Lock()
+        self.DebugWhenFailed=DebugWhenFailed
+        a = csvfile2array(caseconfigfile)
+        cfg={}
+        for i in a:
+            try:
+                if len(i)>0:
+                    cfg.update({i[0].strip().lower():i[1].strip()})
+            except Exception as e:
+                print(e.__str__())
+        self.ServerHost = cfg['serverhost']
+        self.ServerPort = int(cfg['serverport'])
+        self.Name= name.replace('/','_').replace('\\','_')
+        
+        self.LogDir = '%s%s%s'%(logdir,os.sep,'%s%s'%(name.replace('/','_').replace('\\','_'),time.strftime("@%Y%m%d_%H%M%S", time.localtime())))
+        self.LogDir = self.LogDir.replace('\\',os.path.sep).replace('/', os.path.sep)
+
+        os.mkdir(os.path.abspath(self.LogDir))
+        self.Setup=steps[0]
+        self.Run =  steps[1]
+        self.Teardown = steps[2]
+        self.Steps=steps
+        self.SUTs = suts
+        self.Mode = mode.upper()
+        
+
+        import logging
+        logfile = self.LogDir+os.sep+"TC_"+self.Name+".log"
+        logging.basicConfig( level = logging.DEBUG, format = self.Name+' %(asctime)s -%(levelname)s: %(message)s' )
+        from common import CLogger
+        self.logger = CLogger(self.Name)
+        self.hdrlog = logging.FileHandler(logfile)
+        self.logger.setLevel(logging.DEBUG)
+        self.hdrlog .setFormatter(logging.Formatter('%(asctime)s -%(levelname)s: %(message)s'))
+        self.logger.addHandler(self.hdrlog )
+        sutstring =''
+        for sut in self.SUTs.keys():
+            sutstring +='SUT(%s):[%s]\n'%(sut,self.SUTs[sut])
+            self.Session.update({sut:self.Connect2Sut(sut)})
+
+        self.SUTNAME= sorted(suts.keys())
+        self.SUTNAME.append('__case__')
+        
+        self.RecordReplay = [['[cs]'], ['#VAR'],['#SETUP']]
+        newrecord = ['#SUTNAME', 'COMMAND', 'EXPECT', 'WAIT TIME(s)']
+        before1staction= ['#', '','','',]
+        for sut in self.SUTNAME:
+            newrecord.append(sut+' OUTPUT')
+            before1staction.append('')
+        self.RecordReplay.append(newrecord)
+        self.RecordReplay.append(before1staction)
+        self.InitialDone=True
+        #print(self.thInteraction)
+    def troubleshooting(self):
+        import threading
+        self.flagInteraction = True
+        thWebclient=threading.Thread(target=self.QuerySUTOutput,args =[])
+        thWebclient.start()
+
+    def Connect2Sut(self,sutname):
+        ses =None
+        sutattr = self.SUTs.get(sutname)
+        if sutattr["SUT"].strip() =='':
+            if os.name!='nt':
+                sutattr['SUT'] ='Session'
+            else:
+                sutattr['SUT'] ='WinSession'
+
+        classname = sutattr["SUT"]
+        ModuleName = __import__(classname)
+        ClassName = ModuleName.__getattribute__(classname)    
+        ses= ClassName(sutname, sutattr,logger=self.logger ,logpath = self.LogDir)
+        return ses
+    def EndCase(self, force=False, killProcess=False):
+        if self.DebugWhenFailed ==True and self.CaseFailed==True:
+            return 'case failed! and it is waiting for your debug, if you do want to end this case, please try EndCase(force=True)'
+        elif self.flagInteraction==True and force==False:
+            return 'case is in troubleshooting/interaction mode, if you do want to end this case, please try EndCase(force=True)'
+
+        self.bCaseEnd=True
+        import time
+        import os
+        if self.thInteraction and self.thInteraction.isAlive():
+            time.sleep(1)
+        time.sleep(self.MoniterInterval)
+        for sut in self.Session.keys():            
+            self.Session[sut].EndSession()
+
+        from common import csvfile2dict
+        #runcfg = csvfile2dict('./manualrun.cfg')
+        #dbname =runcfg.get('db')
+        #from Database import FetchOne, UpdateRecord
+        
+        #caseinfo = runcfg.get('caseinfo')
+
+        pid = os.getpid()
+        #UpdateRecord(dbname, caseinfo, """status='ended-closed',end_time=%f"""%(time.time()), "status='running' and pid= %d"%(pid))
+        self.logger.info('update database done!')
+        self.SaveCase2File()
+        #if self.Sock:
+            #self.Sock.shutdown(socket.SHUT_RDWR)
+            #self.Sock.close()
+        import signal
+        try:
+            if killProcess:
+                os.kill(os.getpid(), signal.SIGTERM)#exit(0)#
+            pass
+        except:
+            pass
+    def action(self,sut='__case__', cmd='',expect='.*',timeout=1.0):
+        self.ActionCheck([sut, cmd,expect ,float(timeout)])
+    def ActionCheck(self,step=[]):
+        global reRetry,reNo,reNoWait,reNoAction,reCtrl,reAlt,reCtrlAlt
+        #for step in steps:
+        self.info('Start Step:sut(%s), action(%s), expect(%s) within %d'%(step[0],step[1],step[2],int(step[3])))
+        [sut,cmd,exp,Time]=step[:4]
+        [fretry,fNoAction,fNo,fNoWait]=[1,False,False,False]
+        mRetry=re.match(reRetry, cmd)
+        mCtrl= re.match(reCtrl,cmd)
+        mAlt = re.match(reAlt,cmd)
+        mCtrlAlt = re.match(reCtrlAlt,cmd)
+        fCtrl =False
+        fAlt= False
+        if mCtrl:
+            fCtrl=True
+            cmd = mCtrl.group(1)
+        if mAlt:
+            fAlt=True
+            cmd = mAlt.group(1)
+        if mCtrlAlt:
+            fCtrl=True
+            fAlt=True
+            cmd = mCtrlAlt.group(1)
+            
+        if mRetry:
+            fretry= int(mRetry.group(1))
+            cmd = mRetry.group(2)                
+        mNoAction= re.match(reNoAction,cmd)
+        if mNoAction:
+            fNoAction=True
+        mNoWait =   re.match(reNoWait,exp)
+        if mNoWait:
+            fNoWait=True
+            exp=mNoWait.group(1)            
+        mNo = re.match(reNo,exp)
+        if mNo:
+            fNo=True
+            exp=mNo.group(1)
+        
+        s = self.Session[sut]
+        (ActionIsFunction,action,arg,kwarg) = s.ParseCmdInAction(cmd)
+        Failure=True
+        totalretry=fretry
+        while fretry>1:
+            fretry= fretry-1
+            try:
+                if not fNoAction:
+                    if ActionIsFunction:
+                        s.CallFun(action, arg, kwarg)
+                        Failure=False
+                        break                       
+                    else:
+                        s.SendLine(command = cmd, Ctrl=fCtrl, Alt=fAlt)                
+                                    
+                try:
+                    s.Expect(exp,Time,fNoWait)
+                    if not fNo:
+                        Failure=False
+                        break
+                        
+                except Exception as e:
+                    if fNo:
+                        Failure=False
+                        break
+            except Exception as e:
+                if os.name!='nt':
+                    pass#print ('%d/%d failed'%(totalretry-fretry,totalretry), file=sys.stdout)
+                else:
+                    print ('%d/%d failed'%(totalretry-fretry,totalretry), sys.stdout)
+                self.info('%d/%d failed'%(totalretry-fretry,totalretry))
+        IgnoreExp=False
+        if Failure:#try last time
+            if not fNoAction:
+                if ActionIsFunction:
+                    IgnoreExp=True
+                    s.CallFun(action, arg, kwarg)
+                    Failure=False                        
+                else:
+                    s.SendLine(command = cmd, Ctrl=fCtrl, Alt=fAlt)
+            if IgnoreExp:
+                return
+            if fNo:
+                try:
+                    s.Expect(exp,Time,fNoWait)
+                    self.error('unexpect(%s) found within %d'% (exp, int(time)))
+                    raise Exception('unexpect(%s) found within %d'% (exp, int(time)))
+                except Exception as e:
+                    self.info('no unexpected pattern (%s) found'%exp)
+            else:
+                s.Expect(exp,Time,fNoWait)
+                #print('Expect (%s) found!'%(exp))
+
+
+        
+    def ParseCmdInAction(self,cmd):
+        IsCallFunction= True
+        reFunction = re.compile('\s*FUN\s*:\s*(.+?)\s*\(\s*(.*)\s*\)|\s*(.+?)\s*\(\s*(.*)\s*\)',re.IGNORECASE)
+        m = re.match(reFunction, cmd)
+        fun =cmd
+        arg = ""
+        kwarg ={}
+        # noinspection PyComparisonWithNone
+        if m != None :
+            # noinspection PyComparisonWithNone
+            if m.group(1) !=None:
+                fun = m.group(1)
+                arg = m.group(2)
+            else:
+                fun = m.group(3)
+                arg = m.group(4)        
+
+            fun = self.__getattribute__(fun)
+            import inspect
+            (args, varargs, keywords, defaults) =inspect.getargspec(fun)
+            try:
+                parsestr= "self.GetFunArgs(%s)"%((arg))
+                eval(parsestr)
+            except Exception as e:
+                arg.strip()
+                if re.search(',',arg):
+                    self.argvs =arg.split(',')
+                elif len(arg.strip())==0:
+                    self.argvs =[]
+                else:
+                    self.argvs =[self.argvs]
+
+            arg =self.argvs
+            kwarg = self.kwargvs          
+        else:
+            IsCallFunction = False
+            fun = cmd      
+        return (IsCallFunction,fun,arg,kwarg)
+
+    def GetFunArgs(self,*argvs, **kwargs):
+        self.argvs=[]
+        self.kwargvs={}
+        #re-assign for self.argvs and self.kwargvs
+        for arg in argvs:
+            self.argvs.append(arg)
+        for k in kwargs.keys():
+            self.kwargvs.update({k:kwargs[k]})    
+    def CallFun(self,functionName,args=[], kwargs={}):
+        
+        self.fActionInProgress=True
+        resp = functionName(*args, **kwargs)  
+        #self.info(resp)
+        self.fActionInProgress=False
+        # noinspection PyComparisonWithNone
+        if resp ==None:
+            return 'Done'
+        else:
+            return resp 
+       
+    def pp(self,varname):        
+        return repr(self.__getattribute__(varname)).replace('\\\\n','\n').replace('\\\\r','\r')  
+    def set(self,varname,value):
+        return self.__setattr__(varname, value)
+    def SetBreakPoint(self,segment,index):
+        self.info('SetBreakPoint("%s","%s"'%(segment,str(index)))
+        segment= segment.upper()
+        if segment=='SETUP':
+            segment= 0
+        elif segment=='RUN':
+            segment= 1
+        elif segment=='TEARDOWN':
+            segment=2
+        else:
+            msg= 'segment should be one of [SETUP,RUN, TEARDOWN]'
+            self.error(msg)
+            return msg
+        if index<1:
+            index =1
+        self.breakpoint[segment].append(index)
+        self.breakpoint[segment].sort()
+    def str2indexSegment(self,segmentstr):
+        segment= segmentstr.upper()
+        if segment=='SETUP':
+            segment= 0
+        elif segment=='RUN':
+            segment= 1
+        elif segment=='TEARDOWN':
+            segment=2
+        else:
+            raise
+        return segment          
+    def BreakPointCheck(self,segment,index):
+        segment= segment.upper()
+        segment =self.str2indexSegment(segment)  
+        if len(self.breakpoint[segment])>0:
+            self.info('BreakPointCheck("%s","%s")'%(segment,index))
+            for i in self.breakpoint[segment].sort():
+                if index==i:
+                    return True
+        return False    
+    def getIntSegIndex(self,strSegIndex):        
+        global reSegementIndex #=re.compile ('\s*(SETUP|RUN|TEARDOWN)\s*.\s*(\d+)',re.I)
+        m = re.match(reSegementIndex, strSegIndex)
+        seg= self.str2indexSegment(m.group(1).upper())
+        index= int(m.group(2))
+        if index==-1:
+            index = len(self.Steps[seg])+1
+        return seg,index
+    def cpReset(self):
+        self.cp = [0,1]
+    def cpSet(self,seg, index):
+        self.cp =[seg, index]
+        strSeg=['setup','run','teardown']
+        return '%s.%d'%(strSeg[seg],index)
+    def getCP(self):
+        strSeg=['setup','run','teardown']
+        if self.cp[0]>2:
+            seg, index = self.getIntSegIndex('teardown.-1')
+            return 'teardown.%d'%(index+1)
+        return '%s.%d'%(strSeg[self.cp[0]],self.cp[1])        
+    def cpNext(self):
+        l =len(self.Steps[self.cp[0]])
+        self.cp[1]+=1
+        if self.cp[1]>l:
+            self.cp[1]=1
+            self.cp[0]+=1           
+                
+       
+    def RunCase(self,mode,startindex,endindex):
+        self.info('case %s.RunCase(%s,%s,%s)'%(self.Name,mode ,startindex,endindex))
+        startSeg, startIndex= self.getIntSegIndex(startindex)
+        endSeg, endIndex= self.getIntSegIndex(endindex)  
+        mode =mode.lower()
+        self.info('step')
+        self.cpSet(startSeg, startIndex)
+        seg=['setup','run','teardown']
+
+        while self.IndexInRange(self.getCP(), startindex, endindex):
+            if self.BreakPointCheck(seg[self.cp[0]], self.cp[1]):
+                self.flagInteraction=True
+            while self.flagInteraction:
+                time.sleep(0.5)
+            skip=False            
+            if mode =='full':
+                    pass
+            elif mode =='setupteardown' and self.cp[0]==1:
+                skip=True
+            elif mode =='setuprun' and self.cp[0]==2:
+                skip=True
+            elif mode =='runteardown' and self.cp[0]==0:
+                skip=True
+            elif mode =='setupteardown' and self.cp[0]==1:
+                skip=True                
+            elif mode =='setup' and self.cp[0]!=0:
+                skip=True    
+            elif mode =='run' and self.cp[0]!=1:
+                skip=True     
+            elif mode =='teardown' and self.cp[0]!=2:
+                skip=True  
+                                     
+            if not skip:
+                try:
+                    try:
+                        step = self.Steps[self.cp[0]][self.cp[1]-1]
+                    except Exception as e:
+                        break
+                    self.fRunning=True
+                    print('#'*80)
+                    print('#step (%s.%d)'%(seg[self.cp[0]],int(self.cp[1])))
+                    print('#SUT(%s), Action(%s), Exp(%s), Within (%d)'%(step[0],step[1],step[2],int(step[3])))
+
+                    self.info('#'*80)
+                    self.info('#step (%s.%d)'%(seg[self.cp[0]],int(self.cp[1])))
+                    self.info('#SUT(%s), Action(%s), Exp(%s), Within (%d)'%(step[0],step[1],step[2],int(step[3])))
+                    if len(step)>4:
+                        print('#%s'%(step[4]))
+                        self.info('#%s'%(step[4]))
+                    print('#'*80)
+                    self.info('#'*80)
+                    self.AddCmd2RecordReplay(step)
+                    self.ActionCheck(step)
+                    
+                except Exception as e:
+                    self.error(DumpStack(e))
+                    if not self.DebugWhenFailed:
+                        self.bCaseEnd=True
+                        raise
+            self.fRunning=False
+            if not self.flagInteraction:
+                self.bCaseEnd=True
+            self.cpNext()
+        self.info('-'*80)
+    def IndexInRange(self,testIndex,startindex='setup.1',endindex='teardown.-1'):    
+        MAX_ACTION= 65535
+        startSeg, startIndex= self.getIntSegIndex(startindex)
+        endSeg, endIndex= self.getIntSegIndex(endindex)        
+        testSeg, testIndex=self.getIntSegIndex(testIndex)   
+        start = startSeg*MAX_ACTION+startIndex
+        end = endSeg*MAX_ACTION+endIndex
+        test = testSeg*MAX_ACTION+testIndex
+        if test>=start and test<=end:
+            return True
+        else:
+            return False
+
+    def IsAlive(self):
+        if self.bCaseEnd:
+            return False
+        else:
+            return True
+                  
Index: test/test_Case.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- test/test_Case.py	(revision )
+++ test/test_Case.py	(revision )
@@ -0,0 +1,139 @@
+# -*- coding:  UTF-8 -*-
+__author__ = 'Sean Yu'
+__mail__ = 'try.dash.now@gmail.com'
+'''
+created 2015/5/10 
+'''
+import unittest
+import sys,os
+pardir =os.path.dirname(os.path.realpath(__file__))
+pardir= os.path.sep.join(pardir.split(os.path.sep)[:-1])
+sys.path.append(os.path.sep.join([pardir,'lib']))
+print('\n'.join(sys.path))
+
+if __name__=='__main__':
+    from common import DumpStack
+    try:
+        try :
+            abc='str, abc'
+            import inspect
+            print(globals())
+            print(locals())
+            trace= inspect.trace()
+            lastframe = trace[-1][0]
+            locals= repr(lastframe.f_locals).replace('\\\\', '\\')
+            globals= repr(lastframe.f_globals).replace('\\\\', '\\')
+            print(locals)
+            print(globals)
+            raise 'abc'
+
+        except Exception as e:
+            def dumpenv(env):
+                import operator
+                d = {}
+                s=''
+                key =env.keys()
+                key = sorted(key)
+                for k in key:
+                    n = k
+                    o= env[k]
+                    s+='\t%s: %s\n'%(repr(n),repr(o).replace('\\\\', '\\'))
+                print(s)
+                return d
+            dumpenv(locals())
+            def dump_into_ns(env,*x):
+                class A:
+                    def __init__(self):
+                        for n,o in env.items():
+                            vars(self).update({n: o})
+
+                return A(*x)
+
+
+            a = 19
+            b = 'Monday'
+            c = 'Wednesday'
+
+            print()
+            def ftry(x,y):
+                palat = 'obastey'
+                a = x -1
+                b = y +100
+                c = x*y -8
+                return dump_into_ns(locals(),a,b,c)
+
+
+            import sys,traceback
+            h = dump_into_ns(globals())
+            exc_type, exc_value, exc_traceback = sys.exc_info()
+            str = traceback.format_exception(exc_type, exc_value,exc_traceback)
+            str = ''.join(str)
+            str=str.replace('\n', '\n*\t')
+
+            trace= inspect.trace()
+            lastframe = trace[-1][0]
+            locals= repr(lastframe.f_locals).replace('\\\\', '\\')
+            globals= repr(lastframe.f_globals).replace('\\\\', '\\')
+            from common import csvstring2array
+            d =csvstring2array(locals)
+            print(d)
+
+
+
+
+        cmd = 'telnet 192.168.1.112'
+        attr={'TIMEOUT':180,'LOGIN': 'test,assword:,30\nadmin,>,30','CMD':cmd, 'LINEEND':u''+chr(13), 'EXP':'name:', 'SUT':'' }
+
+        #attr={'TIMEOUT': 10,'LOGIN': 'syu,assword:,10\nyxw123,~],20','CMD':'telnet 192.168.1.112' 'EXP':'login:','LINEEND':"u''+chr(13)"}
+        sut = {'tel':attr}
+        tcpport =50001
+        ip = '192.168.1.110'
+        from Server import Server
+
+        svr = Server(ip, tcpport,'Case', 'Case',{'name':'abc', 'suts':sut,  'logdir':'../log', 'caseconfigfile':'../lib/case.cfg'}, 'IsAlive')
+        c = svr.Handler
+        try :
+            raise 'abc'
+
+        except Exception as e:
+            s =DumpStack(e)
+            print(s)
+        print(c.pp('SUTs'))
+        #c.ActionCheck(['telLocal','pwd','~]',10])
+        c.troubleshooting()
+        client='192.168.1.100_61429_CASE2014-07-1702:20:12'
+        resp =c.AddClient(client)
+        resp = c.RequestSUTOutput(client,"tel")
+        c.ActionCheck(['tel','ping localhost','.*', 1])
+        c.ActionCheck(['tel','try 3:ctrl:c','SLV1 >', 30])
+        #time.sleep(10)
+        #resp =c.ActionCheck(['__case__', 'RequestSUTOutput("192.168.1.100_55710_CASE2014-07-1719:42:25""'])
+        #resp =c.ActionCheck(['__case__', 'RequestSUTOutput("192.168.1.100_55710_CASE2014-07-1719:42:25""'])
+        #resp =c.RequestSUTOutput(client,'tel')
+        #time.sleep(10)
+        #resp =c.RequestSUTOutput(client,'tel')
+        #    c.ActionCheck(['telLocal','SLEEP(20.0)','~]',30])
+        #c.ActionCheck(['telLocal','TRY 2:pwd','no:abc',30])
+        #c.ActionCheck(['telLocal','TRY 2:noaction:pwd','nowait:no:abc',30])
+        #import base64
+        import json
+        cmd =['RequestSUTOutput', client, 'tel']
+        jcmd =json.dumps(cmd)
+        from CSocket import SendRequest2Server
+        resp = SendRequest2Server(ip, tcpport, jcmd)
+        print(resp)
+        #time.sleep(2)
+#        resp = SendRequest2Server(ip, tcpport, jcmd)
+        c.EndCase(True)
+        svr.StopServer()
+    except Exception as e:
+
+        print(DumpStack(e))
+        print(e.__str__())
+        msg = traceback.format_exc()
+        print(msg)
+        print('!!!!!!!!!!!!!!!!!!!!!!!!!!!CASE Failed!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!')
+        exit(1)
+
+    print('!!!!!!!!!!!!!!!!!!!!!!!!!!!CASE End!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!')
+    exit(0)
\ No newline at end of file
Index: lib/common.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lib/common.py	(date 1431110806000)
+++ lib/common.py	(revision )
@@ -566,7 +566,7 @@
     key = sorted(key)
     for k in key:
         n = k
-        o= dict[k]
+        o= dicts[k]
         s+='\t%s: %s\n'%(repr(n),repr(o).replace('\\\\', '\\'))
     return s
 import inspect
Index: test/test_Server.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- test/test_Server.py	(revision )
+++ test/test_Server.py	(revision )
@@ -0,0 +1,48 @@
+# -*- coding:  UTF-8 -*-
+__author__ = 'Sean Yu'
+__mail__ = 'try.dash.now@gmail.com'
+'''
+created 2015/5/10 
+'''
+import unittest
+import sys,os
+pardir =os.path.dirname(os.path.realpath(__file__))
+pardir= os.path.sep.join(pardir.split(os.path.sep)[:-1])
+sys.path.append(os.path.sep.join([pardir,'lib']))
+print('\n'.join(sys.path))
+from Case import Case
+from Server import Server
+if __name__=='__main__':
+    import json
+    data = [1,2,3,'a','b', {'d1':'v1'}]
+    data ='abcdef,2,3,4'
+    jstring = json.dumps(data)
+    print('json string:', jstring)
+    jdata = json.loads(jstring)
+
+
+
+    cmd ='telnet localhost'
+    attr={'TIMEOUT': 10,'LOGIN': 'syu,assword:,10\nyxw123,~],20','CMD':'telnet localhost', 'SUT':'', 'EXP':'login:','LINEEND':"u''+chr(13)"}
+    sut = {'tel':attr}
+#    import CCase
+    port =50101
+    svr = Server('localhost', port,'Case', 'Case',{'name':'abc', 'suts':sut,  'logdir':'../log', 'caseconfigfile':'../lib/case.cfg'}, 'IsAlive')
+    from Socket import SendRequest2Server
+    cmd = ['ActionCheck', ['tel', 'ping localhost', '.*', 1]]
+    jcmd = json.dumps(cmd)
+    rsp =SendRequest2Server('localhost', port, jcmd)
+    cmd =['AddClient', '127.0.0.1_41715_CASE2014-12-2513:36:38']
+    jcmd = json.dumps(cmd)
+    rsp =SendRequest2Server('localhost', port, jcmd)
+    cmd = ['EndCase', 1]
+    jcmd = json.dumps(cmd)
+    rsp =SendRequest2Server('localhost', port, jcmd)
+
+    print(rsp)
+
+    import time
+    while svr.IsHandlerAlive():
+
+        time.sleep(1)
+    svr.StopServer()
\ No newline at end of file
Index: lib/case.cfg
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lib/case.cfg	(revision )
+++ lib/case.cfg	(revision )
@@ -0,0 +1,6 @@
+serverhost,localhost
+serverport,50000
+localhost,localhost
+logdir, ../log/tmp/
+
+
Index: lib/Server.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lib/Server.py	(revision )
+++ lib/Server.py	(revision )
@@ -0,0 +1,121 @@
+#! /usr/bin/env python3
+# -*- coding:  UTF-8 -*-
+__author__ = 'Sean Yu'
+__mail__ = 'try.dash.now@gmail.com'
+from Socket import startTCPServer,Rx, Tx, EncodeMsg,SendRequest2Server
+import json
+import inspect
+class Server(object):
+    '''start TCP server, listen on a TCP port of a given host, and initialize an instance of class Handler,
+    receive message from tcp port, and pass it to instance of class Handler, 
+    Attributes is a string in form of csv, for each section, the form is 'attributeName=attributeValue'
+    returns what instance of class Handler returns'''
+    Socket= None # the socket for TCP listening
+    Handler=None # the instance of the given class, TCP message received by TCP thread, and pass to this instance, and response will be sent back
+    bEnd    =False #flag of this instance, if it's True, then TCP daemon thread will be ended 
+    thWait4Request =None
+    thCase =None
+    IsHandlerAliveFun=''
+    host = None
+    port = None
+    def InitHandler(self, ClassName, attributes={},ModuleName =''):
+        if ModuleName== '':
+            ModuleName =ClassName
+        ModuleName = __import__(ModuleName)
+        handlerClass = ModuleName.__getattribute__(ClassName)          
+
+        import inspect
+        (args, varargs, keywords, defaults) =inspect.getargspec(handlerClass.__init__)
+        argument=list(defaults)
+        while argument.__len__()<args.__len__()-1:
+            argument.insert(0,None)
+        for k in attributes.keys():
+            argument[args.index(k)-1]= attributes[k]
+         
+        self.Handler= handlerClass(*argument)
+    
+    def __init__(self,host, listenningPort,Module, Handler,Attributes, IsAlive):
+        self.host=host
+        self.port = listenningPort
+        self.Socket = startTCPServer(host ,listenningPort)
+        self.IsHandlerAliveFun=IsAlive
+        if self.Socket:
+            import threading
+            self.thWait4Request =threading.Thread(target=self.ListenningTcpPort,args =[])
+            self.thWait4Request.start()
+            #self.ListenningTcpPort()
+        else:
+            print("can't start tcpserver (host=%s, listenningport= %s, handler= %s)"%(host,listenningPort,Handler))
+            return
+        self.InitHandler(Handler, Attributes, Module)
+        
+    
+    def CallFunction(self, functionName, args=[]):
+            fun = self.Handler.__getattribute__(functionName)            
+            (argns, varargs, keywords, defaults) =inspect.getargspec(fun)
+            argument=[]
+            if defaults:
+                argument=list(defaults)
+            
+            while argument.__len__()<argns.__len__():#
+                argument.insert(0,None)
+            #argument[0]=self.Handler
+            index = 0
+            #while index <=argns.__len__+1:
+            for a in args:
+                argument[index+1]= args[index]
+                index =index+1
+                
+            argument= argument[1:]
+            result = fun(*argument)
+            return result
+            
+    def Wait4Request(self,conn):
+        
+        try: 
+            request= Rx(conn)         
+            request =json.loads(request)
+            FunctionName = request[0]
+            Args = request[1:]
+            response = 'Done'
+            response= self.CallFunction(FunctionName, Args)
+            if response !='':
+                response =json.dumps(response)
+            Tx(conn,response) 
+        except Exception as e:
+            
+            response= 'Error to call function in Server: %s\nFunctionName: %s , Args: %s'%(e.__str__, FunctionName, Args)
+            response =json.dumps(response) 
+            Tx(conn,response) 
+            #return e)
+
+        try:
+            conn.close()
+        except Exception as e:
+            response= 'Error to call function in Server' 
+            response =json.dumps(response) 
+            Tx(conn,response)
+            conn.close()
+            return response
+          
+    def ListenningTcpPort(self):
+        import threading
+        while not self.bEnd:
+        #Accepting incoming connections
+            try:
+                conn, addr = self.Socket.accept()
+                th =threading.Thread(target=self.Wait4Request,args =[conn])
+                th.start()            
+            except Exception as e:    
+                if e.__str__()==   '[Errno 22] Invalid argument':
+                    pass
+                else:    
+                    print('error in Server::Wait4Request')
+    def IsHandlerAlive(self):
+        return self.CallFunction(self.IsHandlerAliveFun)
+    def StopServer(self):
+        self.bEnd=True
+        import json
+        cmd = ['EndCase', 1]
+        jcmd = json.dumps(cmd)
+        rsp =SendRequest2Server(self.host, self.port, jcmd)
